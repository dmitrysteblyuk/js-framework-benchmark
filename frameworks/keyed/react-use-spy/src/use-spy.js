import{useEffect as B,useState as E,useRef as P}from"react";var l=Symbol("on"),f=Symbol("off"),h=Symbol("effect");function v(t){class e{#e;#t=new Set;constructor(r){this.#e=r}get $(){return t(this),this.#e}set $(r){this.#e=r;for(let c of this.#t)c.notify()}[l](r){this.#t.add(r)}[f](r){this.#t.delete(r)}}return s=>new e(s)}var y=class{#e;#t;#r;constructor(e,s,r){e[l](this),this.#e=e,this.#t=s,this.#r=r,this.execute()}execute(){m(this.#t,this.#e.$)}dispose(){try{this.#r?.removeFromQueue(this),this.#e[f](this)}finally{this.#e=this.#t=this.#r=null}}notify(){S(this.#r,this)}};function x(t){let e,s=a=>{e?.add(a)};class r{#e;#t;#r;#o=new Set;constructor(o,n,i){this.#e=o,this.#t=n,this.#r=i,this.execute()}execute(){let o,n=e,i=new Set;e=i;try{o=this.#e()}finally{e=n;for(let u of this.#o)i.has(u)||u[f](this);for(let u of i)this.#o.has(u)||u[l](this);this.#o=i}m(this.#t,o)}dispose(){try{this.#r?.removeFromQueue(this);for(let o of this.#o)o[f](this)}finally{this.#o=this.#e=this.#t=this.#r=null}}notify(){S(this.#r,this)}}return[(a,o,n=t())=>typeof a=="function"?new r(a,o,n):new y(a,o,n),s]}function m(t,e){typeof t=="function"?t(e):t.next(e)}function S(t,e){t===null?e.execute():t.addToQueue(e)}function T(t){let[e,s]=x(()=>t),c=v(s);return c[h]=e,c}var p=class{#e=new Set;#t=!1;#r=()=>{for(let e of this.#e)e.execute();this.#e.clear(),this.#t=!1};addToQueue(e){this.#e.add(e),!this.#t&&(this.#t=!0,queueMicrotask(this.#r))}removeFromQueue(e){this.#e.delete(e)}};var O=T(new p);function k({useEffect:t,useRef:e,useState:s}){return function(c,{spy:a=O,scheduler:o}={}){let n,i=e();if(i.current===void 0){let d=!1;i.current=a[h](c,b=>{n!==(n=b)&&d&&w(b)},o),d=!0}let[u,w]=s(n);return t(()=>()=>i.current.dispose(),[]),u}}var Y=k({useEffect:B,useState:E,useRef:P});export{p as MicroTaskScheduler,T as createSpy,k as createSpyHook,O as spy,Y as useSpy};
